
/*
 * Service Method For REST Communication
 * using angular low level $http service
 */

(function() {
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  app.service("server", [
    '$http', '$q', function($http, $q) {
      var formatOutput;
      formatOutput = function(array) {
        var formatted;
        formatted = {
          widget_id: array[0],
          key: array[1],
          value: array[2]
        };
        return formatted;
      };
      return {
        queue: [],
        referenceDate: void 0,
        _post: function(data) {
          var deferred, request;
          deferred = $q.defer();
          request = $http({
            method: 'POST',
            url: '/api/widgets',
            data: data
          });

          /* on Success */
          request.success(function(output, status, headers, config) {
            console.log("From Server Success: ", data);
            return deferred.resolve(output);
          });

          /* on error */
          request.error(function(data) {
            return console.log("From Server ", status, ":ERROR ", data);
          });
          return deferred.promise;
        },
        publish: function(onComplete) {
          var callback, entry, i, j, key, output, ref, tempQueue, uniqueKeys;
          if (this.queue.length === 0) {
            return;
          }
          tempQueue = angular.copy(this.queue);
          uniqueKeys = [];
          output = [];
          callback = function() {
            return onComplete(output);
          };
          for (i = j = ref = tempQueue.length - 1; j >= 0; i = j += -1) {
            entry = tempQueue[i];
            key = entry['widget_id'] + '-----' + entry['key'];
            if (indexOf.call(uniqueKeys, key) >= 0) {
              continue;
            }
            uniqueKeys.push(key);
            output.push(entry);
          }
          this._post(output).then(callback);
          this.queue = [];
        },
        post: function(widgetId, key, data) {
          return this._post(formatOutput(arguments));
        },
        postToQueue: function(widgetId, key, data) {
          return this.queue.push(formatOutput(arguments));
        }
      };
    }
  ]);

}).call(this);

//# sourceMappingURL=data:application/json;base64,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QUFPLE1BQVAsQ0FBYyxDQUFDLElBQWYsQ0FBb0IsUUFBcEIsQ0F0QkEsQ0FBQTtBQUFBLFVBd0JBLElBQUMsQ0FBQSxLQUFELEdBQVMsRUF4QlQsQ0FESztRQUFBLENBdEJOO0FBQUEsUUF3REgsSUFBQSxFQUFLLFNBQUMsUUFBRCxFQUFVLEdBQVYsRUFBYyxJQUFkLEdBQUE7QUFDRCxpQkFBTyxJQUFDLENBQUEsS0FBRCxDQUFPLFlBQUEsQ0FBYSxTQUFiLENBQVAsQ0FBUCxDQURDO1FBQUEsQ0F4REY7QUFBQSxRQTRESCxXQUFBLEVBQVksU0FBQyxRQUFELEVBQVUsR0FBVixFQUFjLElBQWQsR0FBQTtpQkFDUixJQUFDLENBQUEsS0FBSyxDQUFDLElBQVAsQ0FBWSxZQUFBLENBQWEsU0FBYixDQUFaLEVBRFE7UUFBQSxDQTVEVDtPQUFQLENBVCtCO0lBQUEsQ0FBZDtHQUFyQixDQUpBLENBQUE7QUFBQSIsImZpbGUiOiJzZXJ2ZXIuanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8iLCJzb3VyY2VzQ29udGVudCI6WyIjIyNcbiMgU2VydmljZSBNZXRob2QgRm9yIFJFU1QgQ29tbXVuaWNhdGlvblxuIyB1c2luZyBhbmd1bGFyIGxvdyBsZXZlbCAkaHR0cCBzZXJ2aWNlXG4jIyNcbmFwcC5zZXJ2aWNlIFwic2VydmVyXCIsWyckaHR0cCcsJyRxJywoJGh0dHAsJHEpIC0+XG4gICAgZm9ybWF0T3V0cHV0ID0gKGFycmF5KS0+XG4gICAgICAgIGZvcm1hdHRlZCA9IHtcbiAgICAgICAgICAgIHdpZGdldF9pZCA6IGFycmF5WzBdXG4gICAgICAgICAgICBrZXkgICAgICAgOiBhcnJheVsxXVxuICAgICAgICAgICAgdmFsdWUgICAgIDogYXJyYXlbMl1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBxdWV1ZSA6IFtdXG5cbiAgICAgICAgcmVmZXJlbmNlRGF0ZSA6IHVuZGVmaW5lZFxuXG4gICAgICAgICMgYmFzZSBtZXRob2QgdG8gc3VibWl0IHRvIHNlcnZlclxuICAgICAgICBfcG9zdDooZGF0YSkgLT5cbiAgICAgICAgICAgIGRlZmVycmVkID0gJHEuZGVmZXIoKVxuXG4gICAgICAgICAgICByZXF1ZXN0ID0gJGh0dHAobWV0aG9kOidQT1NUJyx1cmw6Jy9hcGkvd2lkZ2V0cycsZGF0YTpkYXRhKVxuXG4gICAgICAgICAgICAjIyMgb24gU3VjY2VzcyAjIyNcbiAgICAgICAgICAgIHJlcXVlc3Quc3VjY2VzcyAob3V0cHV0LCBzdGF0dXMsIGhlYWRlcnMsIGNvbmZpZykgLT5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyBcIkZyb20gU2VydmVyIFN1Y2Nlc3M6IFwiLGRhdGFcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKG91dHB1dClcblxuICAgICAgICAgICAgIyMjIG9uIGVycm9yICMjI1xuICAgICAgICAgICAgcmVxdWVzdC5lcnJvciAoZGF0YSkgLT5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyBcIkZyb20gU2VydmVyIFwiLHN0YXR1cyxcIjpFUlJPUiBcIixkYXRhXG5cbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG5cbiAgICAgICAgcHVibGlzaDogKG9uQ29tcGxldGUpLT5cbiAgICAgICAgICAgIHJldHVybiBpZiBAcXVldWUubGVuZ3RoIGlzIDBcbiAgICAgICAgICAgIHRlbXBRdWV1ZSA9IGFuZ3VsYXIuY29weShAcXVldWUpXG5cbiAgICAgICAgICAgIHVuaXF1ZUtleXMgPSBbXVxuICAgICAgICAgICAgb3V0cHV0ID0gW11cblxuICAgICAgICAgICAgY2FsbGJhY2sgPSAtPlxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGUob3V0cHV0KVxuXG5cbiAgICAgICAgICAgICMgbG9vcCBpbiByZXZlcnNlICwgcmVtb3ZlIGR1cGxpY2F0ZXMuIG5ld2VyIG9uZXMgYXJlIHBvc3RlZCBhbmQgb2xkIGFyZSByZW1vdmVkXG4gICAgICAgICAgICBmb3IgaSBpbiBbdGVtcFF1ZXVlLmxlbmd0aCAtIDEuLjBdIGJ5IC0xXG4gICAgICAgICAgICAgICAgZW50cnkgPSB0ZW1wUXVldWVbaV1cbiAgICAgICAgICAgICAgICBrZXkgPSBlbnRyeVsnd2lkZ2V0X2lkJ10gKyAnLS0tLS0nICsgZW50cnlbJ2tleSddXG5cbiAgICAgICAgICAgICAgICBpZiBrZXkgaW4gdW5pcXVlS2V5c1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgICAgICAgICAgdW5pcXVlS2V5cy5wdXNoIGtleVxuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoIGVudHJ5XG5cblxuICAgICAgICAgICAgQF9wb3N0KG91dHB1dCkudGhlbiBjYWxsYmFja1xuXG4gICAgICAgICAgICBAcXVldWUgPSBbXVxuXG4gICAgICAgICAgICByZXR1cm5cblxuXG5cblxuXG4gICAgICAgICNpbW1lZGlhdGVseSBzdWJtaXRcbiAgICAgICAgcG9zdDood2lkZ2V0SWQsa2V5LGRhdGEpLT5cbiAgICAgICAgICAgIHJldHVybiBAX3Bvc3QoZm9ybWF0T3V0cHV0KGFyZ3VtZW50cykpXG5cbiAgICAgICAgIyBxdWV1ZSBhbmQgc2F2ZSBsYXRlclxuICAgICAgICBwb3N0VG9RdWV1ZTood2lkZ2V0SWQsa2V5LGRhdGEpLT5cbiAgICAgICAgICAgIEBxdWV1ZS5wdXNoKGZvcm1hdE91dHB1dChhcmd1bWVudHMpKVxuICAgIH1cbl1cbiJdfQ==